fprintf('=========================================\n');
fprintf('   平面弹性有限元分析 \n');
fprintf('=========================================\n\n');

E = 210e9;
nu = 0.3;
thickness = 0.01;

fprintf('选择分析类型:\n');
fprintf('  1. 平面应力 (plane stress) - 适用于薄板结构\n');
fprintf('  2. 平面应变 (plane strain) - 适用于厚结构或长柱体\n');
choice = input('输入选择 (1 或 2, 默认1): ');

if isempty(choice) || choice == 1
    analysis_type = 'plane_stress';
    fprintf('  已选择: 平面应力\n');
elseif choice == 2
    analysis_type = 'plane_strain';
    fprintf('  已选择: 平面应变\n');
else
    fprintf('  无效选择，使用默认值: 平面应力\n');
    analysis_type = 'plane_stress';
end

mesh_file = 'plate_with_hole.msh';
fprintf('网格文件: %s\n', mesh_file);

apply_traction = true;
traction_value = 1e6;
fixed_boundary = 'left';
loaded_boundary = 'right';

fprintf('\n边界条件:\n');
fprintf('  固定边界: %s\n', fixed_boundary);
fprintf('  加载边界: %s\n', loaded_boundary);
fprintf('  面力大小: %.2e %s\n', traction_value, ...
    strcmp(analysis_type, 'plane_stress') ? 'Pa' : 'N/m');

fprintf('\n--- 创建材料矩阵 ---\n');

if strcmp(analysis_type, 'plane_stress')
    D = (E/(1-nu^2)) * [1, nu, 0;
                        nu, 1, 0;
                        0, 0, (1-nu)/2];
    fprintf('  平面应力材料矩阵:\n');
else
    D = (E/((1+nu)*(1-2*nu))) * [1-nu, nu, 0;
                                 nu, 1-nu, 0;
                                 0, 0, (1-2*nu)/2];
    fprintf('  平面应变材料矩阵:\n');
end

fprintf('    [%.3e, %.3e, %.3e]\n', D(1,:));
fprintf('    [%.3e, %.3e, %.3e]\n', D(2,:));
fprintf('    [%.3e, %.3e, %.3e]\n', D(3,:));

fprintf('\n--- 读取网格文件 ---\n');

if ~exist(mesh_file, 'file')
    error('网格文件不存在: %s\n请先生成网格或检查文件路径。', mesh_file);
end

fid = fopen(mesh_file, 'r');
if fid == -1
    error('无法打开文件: %s', mesh_file);
end

coordinates = [];
elements = [];
nodesets = struct();
edgesets = struct();

section = '';
line_count = 0;
node_section_started = false;
element_section_started = false;

while ~feof(fid)
    line = fgetl(fid);
    line_count = line_count + 1;
    
    if isempty(line)
        continue;
    end

    if strcmp(line(1), '$')
        section = line(2:end);
        
        if strcmp(section, 'Nodes')
            node_section_started = true;
            element_section_started = false;
        elseif strcmp(section, 'Elements')
            element_section_started = true;
            node_section_started = false;
        elseif strcmp(section, 'EndNodes') || strcmp(section, 'EndElements')
            node_section_started = false;
            element_section_started = false;
        end
        continue;
    end

    if node_section_started
        if isempty(coordinates)
            n_nodes = str2double(line);
            coordinates = zeros(n_nodes, 3);
            node_counter = 1;
            continue;
        end

        data = sscanf(line, '%f');
        if length(data) >= 4
            node_id = data(1);
            coordinates(node_id, :) = data(2:4);
            node_counter = node_counter + 1;
        end

    elseif element_section_started
        if isempty(elements)
            n_elems = str2double(line);
            elements = cell(n_elems, 1);
            element_counter = 1;
            continue;
        end

        data = sscanf(line, '%f');
        if ~isempty(data)
            elem_id = data(1);
            elem_type = data(2);
            n_tags = data(3);

            tag_start = 4;
            node_start = tag_start + n_tags;

            if elem_type == 3 
                nodes = data(node_start:end)';
                elements{elem_id} = nodes;

                if n_tags >= 2
                    phys_group = data(5);
                    group_name = sprintf('group%d', phys_group);
                    if ~isfield(edgesets, group_name)
                        edgesets.(group_name) = [];
                    end
                    edgesets.(group_name) = [edgesets.(group_name); elem_id];
                end
            elseif elem_type == 2 
                nodes = data(node_start:end)';
                elements{elem_id} = nodes;
            end
        end
    end
end

fclose(fid);

valid_elems = ~cellfun('isempty', elements);
element_ids = find(valid_elems);
elems = zeros(length(element_ids), 4);
for i = 1:length(element_ids)
    elems(i, :) = elements{element_ids(i)};
end

nodes = coordinates(:, 1:2);

fprintf('  网格信息:\n');
fprintf('    节点数: %d\n', size(nodes, 1));
fprintf('    单元数: %d\n', size(elems, 1));
fprintf('    坐标范围: x ∈ [%.3f, %.3f], y ∈ [%.3f, %.3f]\n', ...
    min(nodes(:,1)), max(nodes(:,1)), min(nodes(:,2)), max(nodes(:,2)));



if isfield(boundary, 'left')
    left_nodes = boundary.left;
    fprintf('左边界 (%d个节点) - 完全固定\n', length(left_nodes));
    
    for i = 1:length(left_nodes)
        node = left_nodes(i);
        dirichlet_nodes = [dirichlet_nodes; node];
        dirichlet_dofs = [dirichlet_dofs; node*2-1; node*2];
        dirichlet_values = [dirichlet_values; 0; 0];
    end
end

fprintf('  Neumann边界: ');
neumann_edges = [];
neumann_tractions = [];

if isfield(boundary, 'right')
    right_edges = boundary.right;
    fprintf('右边界 (%d条边) - 施加拉力\n', length(right_edges));
    
    traction = [1e6; 0];  % [tx; ty] (Pa)
    
    for i = 1:length(right_edges)
        neumann_edges = [neumann_edges; right_edges(i, :)];
        neumann_tractions = [neumann_tractions; traction];
    end
end

fprintf('\n组装刚度矩阵和载荷向量...\n');

n_nodes = size(nodes, 1);
n_dofs = 2 * n_nodes;
K = sparse(n_dofs, n_dofs);
F = sparse(n_dofs, 1);

fprintf('  处理单元...\n');
for e = 1:size(elems, 1)
    elem_nodes = elems(e, :);
    
    node_coords = nodes(elem_nodes, :);
    
    [Ke, Fe] = computeQ4Element(E, nu, thickness, node_coords);
    
    dof_indices = getDofIndices(elem_nodes);
    K(dof_indices, dof_indices) = K(dof_indices, dof_indices) + Ke;
    F(dof_indices) = F(dof_indices) + Fe;
end

if ~isempty(neumann_edges)
    fprintf('  施加Neumann边界条件...\n');
    F = applyNeumannBC(F, nodes, neumann_edges, neumann_tractions, thickness);
end

fprintf('\n施加Dirichlet边界条件...\n');
[K_mod, F_mod] = applyDirichletBC(K, F, dirichlet_dofs, dirichlet_values);

fprintf('\n求解线性系统...\n');
U = K_mod \ F_mod;

displacements = reshape(U, 2, n_nodes)';
Ux = displacements(:, 1);
Uy = displacements(:, 2);

fprintf('  最大位移: Ux_max = %.2e m, Uy_max = %.2e m\n', ...
    max(abs(Ux)), max(abs(Uy)));

fprintf('\n计算单元应力和应变...\n');
[element_stresses, element_strains, vonMises] = ...
    computeStressStrain(nodes, elems, displacements, E, nu);

fprintf('\n生成可视化结果...\n');
plotResults(nodes, elems, displacements, element_stresses, vonMises);

outputResults(nodes, displacements, element_stresses, vonMises);

fprintf('\n=== 求解完成 ===\n');

