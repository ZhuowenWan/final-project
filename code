fprintf('=========================================\n');
fprintf('   平面弹性有限元分析\n');
fprintf('=========================================\n\n');

E = 210e9;
nu = 0.3;
thickness = 0.01;

fprintf('选择分析类型:\n');
fprintf('  1. 平面应力 (plane stress)\n');
fprintf('  2. 平面应变 (plane strain)\n');
choice = input('输入选择 (1 或 2, 默认1): ');

if isempty(choice) || choice == 1
    analysis_type = 'plane_stress';
    fprintf('  已选择: 平面应力\n');
elseif choice == 2
    analysis_type = 'plane_strain';
    fprintf('  已选择: 平面应变\n');
else
    fprintf('  无效选择，使用默认值: 平面应力\n');
    analysis_type = 'plane_stress';
end

fprintf('\n选择分析模式:\n');
fprintf('  1. 实际工程问题\n');
fprintf('  2. 制造解验证（收敛率分析）\n');
mode_choice = input('输入选择 (1 或 2, 默认2): ');

if isempty(mode_choice) || mode_choice == 2
    manufactured_solution = true;
    fprintf('  已选择: 制造解验证模式\n');
else
    manufactured_solution = false;
    fprintf('  已选择: 实际工程问题模式\n');
end

if manufactured_solution
    fprintf('\n--- 制造解定义 ---\n');
    
    u_exact_func = @(x, y) deal(...
        0.01 * (x.^2 .* y + sin(pi*x) .* cos(pi*y)), ...
        0.005 * (x .* y.^2 + cos(pi*x) .* sin(pi*y)));

    du_x_dx_func = @(x, y) 0.01 * (2*x.*y + pi*cos(pi*x).*cos(pi*y));
    du_x_dy_func = @(x, y) 0.01 * (x.^2 - pi*sin(pi*x).*sin(pi*y));

    du_y_dx_func = @(x, y) 0.005 * (y.^2 - pi*sin(pi*x).*sin(pi*y));
    du_y_dy_func = @(x, y) 0.005 * (2*x.*y + pi*cos(pi*x).*cos(pi*y));
    
    fprintf('  制造解:\n');
    fprintf('    u_x = 0.01*(x²y + sin(πx)cos(πy))\n');
    fprintf('    u_y = 0.005*(xy² + cos(πx)sin(πy))\n');
end

if manufactured_solution
    refinement_levels = 4;
    mesh_sizes = [8, 16, 32, 64];

    h_values = zeros(refinement_levels, 1);
    L2_errors = zeros(refinement_levels, 1);
    H1_errors = zeros(refinement_levels, 1);
    L2_rates = zeros(refinement_levels-1, 1);
    H1_rates = zeros(refinement_levels-1, 1);
else
    refinement_levels = 1;
    mesh_sizes = 32 ;
end

for level = 1:refinement_levels
    fprintf('\n\n=========================================\n');
    fprintf('   网格细化级别 %d/%d (单元数: %dx%d)\n', ...
        level, refinement_levels, mesh_sizes(level), mesh_sizes(level));
    fprintf('=========================================\n');

    fprintf('\n--- 生成结构化网格 ---\n');

    x_min = 0; x_max = 1;
    y_min = 0; y_max = 1;
    
    nx = mesh_sizes(level);
    ny = mesh_sizes(level);

    x_nodes = linspace(x_min, x_max, nx+1);
    y_nodes = linspace(y_min, y_max, ny+1);
    
    [X, Y] = meshgrid(x_nodes, y_nodes);
    nodes = [X(:), Y(:)];
    n_nodes = size(nodes, 1);
    
    fprintf('  节点数: %d\n', n_nodes);

    elems = zeros(nx*ny, 4);
    elem_counter = 1;
    
    for i = 1:nx
        for j = 1:ny
            node1 = (j-1)*(nx+1) + i;
            node2 = (j-1)*(nx+1) + i + 1;
            node3 = j*(nx+1) + i + 1;
            node4 = j*(nx+1) + i;
            
            elems(elem_counter, :) = [node1, node2, node3, node4];
            elem_counter = elem_counter + 1;
        end
    end
    
    n_elems = size(elems, 1);
    fprintf('  单元数: %d\n', n_elems);

    h = (x_max - x_min) / nx;
    h_values(level) = h;
    fprintf('  网格尺寸 h = %.4f\n', h);

    fprintf('\n--- 设置边界 ---\n');

    left_nodes = find(nodes(:,1) == x_min);
    right_nodes = find(nodes(:,1) == x_max);
    bottom_nodes = find(nodes(:,2) == y_min);
    top_nodes = find(nodes(:,2) == y_max);

    boundary_nodes = unique([left_nodes; right_nodes; bottom_nodes; top_nodes]);
    fprintf('  边界节点数: %d\n', length(boundary_nodes));

    boundary_edges = [];

    for j = 1:ny
        node1 = (j-1)*(nx+1) + 1;
        node2 = j*(nx+1) + 1;
        boundary_edges = [boundary_edges; node1, node2];
    end

    for j = 1:ny
        node1 = (j-1)*(nx+1) + (nx+1);
        node2 = j*(nx+1) + (nx+1);
        boundary_edges = [boundary_edges; node1, node2];
    end

    for i = 1:nx
        node1 = i;
        node2 = i + 1;
        boundary_edges = [boundary_edges; node1, node2];
    end

    for i = 1:nx
        node1 = ny*(nx+1) + i;
        node2 = ny*(nx+1) + i + 1;
        boundary_edges = [boundary_edges; node1, node2];
    end
    
    fprintf('  边界边数: %d\n', size(boundary_edges, 1));

    fprintf('\n--- 创建材料矩阵 ---\n');
    
    if strcmp(analysis_type, 'plane_stress')
        D = (E/(1-nu^2)) * [1, nu, 0;
                            nu, 1, 0;
                            0, 0, (1-nu)/2];
        fprintf('  平面应力材料矩阵\n');
    else
        D = (E/((1+nu)*(1-2*nu))) * [1-nu, nu, 0;
                                     nu, 1-nu, 0;
                                     0, 0, (1-2*nu)/2];
        fprintf('  平面应变材料矩阵\n');
    end

    fprintf('\n--- 设置边界条件 ---\n');
    
    dirichlet_dofs = [];
    dirichlet_values = [];
    neumann_edges = [];
    neumann_tractions = [];
    
    if manufactured_solution
        fprintf('  制造解模式: 在边界节点施加精确位移\n');

        for i = 1:length(boundary_nodes)
            node = boundary_nodes(i);
            x = nodes(node, 1);
            y = nodes(node, 2);
            
            [u_exact, v_exact] = u_exact_func(x, y);
            
            dirichlet_dofs = [dirichlet_dofs; node*2-1; node*2];
            dirichlet_values = [dirichlet_values; u_exact; v_exact];
        end
        
        fprintf('  约束自由度: %d\n', length(dirichlet_dofs));
    else
        fprintf('  实际工程问题模式\n');
        
        for i = 1:length(left_nodes)
            node = left_nodes(i);
            dirichlet_dofs = [dirichlet_dofs; node*2-1; node*2];
            dirichlet_values = [dirichlet_values; 0; 0];
        end
        fprintf('  固定左边界: %d个节点\n', length(left_nodes));

        traction_value = 1e6;
        for i = 1:length(right_nodes)-1
            node1 = right_nodes(i);
            node2 = right_nodes(i+1);
            neumann_edges = [neumann_edges; node1, node2];
            neumann_tractions = [neumann_tractions, [traction_value; 0]];
        end
        fprintf('  右边界面力: %.2e Pa\n', traction_value);
    end

    fprintf('\n--- 单元计算准备 ---\n');
    
    Q4_shape = @(xi, eta) deal(...
        0.25 * [(1-xi)*(1-eta); (1+xi)*(1-eta); (1+xi)*(1+eta); (1-xi)*(1+eta)]', ...
        0.25 * [-(1-eta); (1-eta); (1+eta); -(1+eta)], ...
        0.25 * [-(1-xi); -(1+xi); (1+xi); (1-xi)]);
    
    gauss_points = [-1/sqrt(3), -1/sqrt(3);
                    1/sqrt(3), -1/sqrt(3);
                    1/sqrt(3),  1/sqrt(3);
                   -1/sqrt(3),  1/sqrt(3)];
    gauss_weights = [1, 1, 1, 1];
    
    fprintf('  使用2×2 Gauss积分\n');

    fprintf('\n--- 组装有限元系统 ---\n');
    
    n_dofs = 2 * n_nodes;
    K = sparse(n_dofs, n_dofs);
    F = sparse(n_dofs, 1);
    
    fprintf('  系统自由度: %d\n', n_dofs);
    fprintf('  组装单元刚度矩阵...\n');
    
    progress_interval = max(1, floor(n_elems/10));
    
    for e = 1:n_elems
        if mod(e, progress_interval) == 0
            fprintf('    %d/%d (%.0f%%)\n', e, n_elems, e/n_elems*100);
        end
        
        elem_nodes = elems(e, :);
        node_coords = nodes(elem_nodes, :);
        
        Ke = zeros(8, 8);
        Fe = zeros(8, 1);
        
        for g = 1:4
            xi = gauss_points(g, 1);
            eta = gauss_points(g, 2);
            
            [N, dN_dxi, dN_deta] = Q4_shape(xi, eta);

            dx_dxi = dN_dxi' * node_coords(:,1);
            dy_dxi = dN_dxi' * node_coords(:,2);
            dx_deta = dN_deta' * node_coords(:,1);
            dy_deta = dN_deta' * node_coords(:,2);
            
            J = [dx_dxi, dy_dxi; dx_deta, dy_deta];
            detJ = det(J);
            
            if detJ <= 0
                warning('单元 %d 的雅可比行列式为负: detJ = %.2e', e, detJ);
                detJ = abs(detJ);
            end
            
            invJ = inv(J);

            dN_dx = invJ(1,1)*dN_dxi + invJ(1,2)*dN_deta;
            dN_dy = invJ(2,1)*dN_dxi + invJ(2,2)*dN_deta;

            B = zeros(3, 8);
            for j = 1:4
                B(1, 2*j-1) = dN_dx(j);
                B(2, 2*j)   = dN_dy(j);
                B(3, 2*j-1) = dN_dy(j);
                B(3, 2*j)   = dN_dx(j);
            end

            if strcmp(analysis_type, 'plane_stress')
                thickness_factor = thickness;
            else
                thickness_factor = 1.0;
            end

            Ke = Ke + B' * D * B * detJ * thickness_factor * gauss_weights(g);

            if manufactured_solution
                x_g = N' * node_coords(:,1);
                y_g = N' * node_coords(:,2);

                f_x = 1e6 * sin(pi*x_g) * cos(pi*y_g);
                f_y = 0.5e6 * cos(pi*x_g) * sin(pi*y_g);

                f_body = [f_x; f_y];

                Fe = Fe + N' * f_body * detJ * thickness_factor * gauss_weights(g);
            end
        end

        dof_indices = zeros(8, 1);
        for j = 1:4
            dof_indices(2*j-1) = 2*elem_nodes(j) - 1;
            dof_indices(2*j)   = 2*elem_nodes(j);
        end
        
        K(dof_indices, dof_indices) = K(dof_indices, dof_indices) + Ke;
        F(dof_indices) = F(dof_indices) + Fe;
    end

    if ~isempty(neumann_edges)
        fprintf('\n  施加面力边界条件...\n');
        
        if strcmp(analysis_type, 'plane_stress')
            thickness_factor = thickness;
        else
            thickness_factor = 1.0;
        end
        
        for i = 1:size(neumann_edges, 1)
            node1 = neumann_edges(i, 1);
            node2 = neumann_edges(i, 2);
            
            x1 = nodes(node1, :);
            x2 = nodes(node2, :);
            
            edge_length = norm(x2 - x1);
            traction = neumann_tractions(:, i);
            
            f_total = traction * edge_length * thickness_factor;
            f_node = f_total / 2;
            
            dof1 = [2*node1-1, 2*node1];
            dof2 = [2*node2-1, 2*node2];
            
            F(dof1) = F(dof1) + f_node;
            F(dof2) = F(dof2) + f_node;
        end
    end

    fprintf('\n--- 施加位移边界条件 ---\n');
    fprintf('  处理 %d 个约束自由度\n', length(dirichlet_dofs));

    penalty = 1e30 * max(max(abs(K(K~=0))));
    if isnan(penalty) || isinf(penalty) || penalty == 0
        penalty = 1e30;
    end
    
    K_mod = K;
    F_mod = F;
    
    for i = 1:length(dirichlet_dofs)
        dof = dirichlet_dofs(i);
        value = dirichlet_values(i);
        
        K_mod(dof, dof) = penalty;
        F_mod(dof) = penalty * value;

        for j = 1:n_dofs
            if j ~= dof
                F_mod(j) = F_mod(j) - K(j, dof) * value;
                K_mod(j, dof) = 0;
                K_mod(dof, j) = 0;
            end
        end
    end

    fprintf('\n--- 求解线性系统 ---\n');
    fprintf('  求解 %d×%d 稀疏系统...\n', n_dofs, n_dofs);
    
    U = K_mod \ F_mod;
    
    displacements = reshape(U, 2, n_nodes)';
    Ux = displacements(:, 1);
    Uy = displacements(:, 2);

    if manufactured_solution
        fprintf('\n--- 计算误差 ---\n');
        
        L2_error_sq = 0;
        H1_error_sq = 0;
        L2_norm_exact_sq = 0;
        H1_norm_exact_sq = 0;

        a = 1/sqrt(3);
        quad_points = [-a, -a; a, -a; a, a; -a, a];
        quad_weights = [1, 1, 1, 1];
        
        for e = 1:n_elems
            elem_nodes = elems(e, :);
            elem_coords = nodes(elem_nodes, :);
            elem_disp = displacements(elem_nodes, :);
            
            for q = 1:4
                xi = quad_points(q, 1);
                eta = quad_points(q, 2);

                N = 0.25 * [(1-xi)*(1-eta); (1+xi)*(1-eta); (1+xi)*(1+eta); (1-xi)*(1+eta)];

                dN_dxi = 0.25 * [-(1-eta); (1-eta); (1+eta); -(1+eta)];
                dN_deta = 0.25 * [-(1-xi); -(1+xi); (1+xi); (1-xi)];

                J = [dN_dxi' * elem_coords(:,1), dN_dxi' * elem_coords(:,2);
                     dN_deta' * elem_coords(:,1), dN_deta' * elem_coords(:,2)];
                detJ = det(J);
                
                if detJ <= 0
                    detJ = abs(detJ);
                end

                x_q = N' * elem_coords(:,1);
                y_q = N' * elem_coords(:,2);

                u_num = N' * elem_disp(:,1);
                v_num = N' * elem_disp(:,2);

                [u_exact, v_exact] = u_exact_func(x_q, y_q);

                invJ = inv(J);
                dN_dx = invJ(1,1)*dN_dxi + invJ(1,2)*dN_deta;
                dN_dy = invJ(2,1)*dN_dxi + invJ(2,2)*dN_deta;

                du_num_dx = dN_dx' * elem_disp(:,1);
                du_num_dy = dN_dy' * elem_disp(:,1);
                dv_num_dx = dN_dx' * elem_disp(:,2);
                dv_num_dy = dN_dy' * elem_disp(:,2);

                du_exact_dx_val = du_x_dx_func(x_q, y_q);
                du_exact_dy_val = du_x_dy_func(x_q, y_q);
                dv_exact_dx_val = du_y_dx_func(x_q, y_q);
                dv_exact_dy_val = du_y_dy_func(x_q, y_q);

                L2_error_sq = L2_error_sq + quad_weights(q) * detJ * ...
                    ((u_num - u_exact)^2 + (v_num - v_exact)^2);
                
                L2_norm_exact_sq = L2_norm_exact_sq + quad_weights(q) * detJ * ...
                    (u_exact^2 + v_exact^2);

                H1_error_sq = H1_error_sq + quad_weights(q) * detJ * ...
                    ((du_num_dx - du_exact_dx_val)^2 + ...
                     (du_num_dy - du_exact_dy_val)^2 + ...
                     (dv_num_dx - dv_exact_dx_val)^2 + ...
                     (dv_num_dy - dv_exact_dy_val)^2);
                
                H1_norm_exact_sq = H1_norm_exact_sq + quad_weights(q) * detJ * ...
                    (du_exact_dx_val^2 + du_exact_dy_val^2 + ...
                     dv_exact_dx_val^2 + dv_exact_dy_val^2);
            end
        end

        L2_error = sqrt(L2_error_sq);
        L2_norm_exact = sqrt(L2_norm_exact_sq);
        relative_L2_error = L2_error / L2_norm_exact;
        
        H1_error = sqrt(H1_error_sq);
        H1_norm_exact = sqrt(H1_norm_exact_sq);
        relative_H1_error = H1_error / H1_norm_exact;

        L2_errors(level) = relative_L2_error;
        H1_errors(level) = relative_H1_error;
        
        fprintf('\n  误差结果 (级别 %d):\n', level);
        fprintf('    网格尺寸 h = %.4f\n', h);
        fprintf('    相对L₂误差 = %.4e\n', relative_L2_error);
        fprintf('    相对H₁误差 = %.4e\n', relative_H1_error);

        if level > 1
            L2_rate = log(L2_errors(level-1)/L2_errors(level)) / log(h_values(level-1)/h_values(level));
            H1_rate = log(H1_errors(level-1)/H1_errors(level)) / log(h_values(level-1)/h_values(level));
            
            L2_rates(level-1) = L2_rate;
            H1_rates(level-1) = H1_rate;
            
            fprintf('    收敛率: L₂ = %.3f, H₁ = %.3f\n', L2_rate, H1_rate);
        end
    end

    if (manufactured_solution && level == refinement_levels) || ...
       (~manufactured_solution && level == 1)
        
        fprintf('\n--- 生成可视化结果 ---\n');
        
        figure('Position', [50, 50, 1200, 800], ...
               'Name', sprintf('有限元分析结果 - 级别 %d', level), ...
               'NumberTitle', 'off');

        subplot(2, 3, 1);
        patch('Faces', elems, 'Vertices', nodes, ...
              'FaceColor', 'none', 'EdgeColor', 'b', 'LineWidth', 0.5);
        title('原始网格', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('x', 'FontSize', 10); ylabel('y', 'FontSize', 10);
        axis equal tight; grid on;

        subplot(2, 3, 2);
        patch('Faces', elems, 'Vertices', nodes, ...
              'FaceVertexCData', Ux, 'FaceColor', 'interp', 'EdgeColor', 'none');
        colorbar;
        title('x方向位移 U_x', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('x', 'FontSize', 10); ylabel('y', 'FontSize', 10);
        axis equal tight; grid on;

        subplot(2, 3, 3);
        patch('Faces', elems, 'Vertices', nodes, ...
              'FaceVertexCData', Uy, 'FaceColor', 'interp', 'EdgeColor', 'none');
        colorbar;
        title('y方向位移 U_y', 'FontSize', 12, 'FontWeight', 'bold');
        xlabel('x', 'FontSize', 10); ylabel('y', 'FontSize', 10);
        axis equal tight; grid on;
        
        if manufactured_solution
            subplot(2, 3, 4);
            [u_exact_all, v_exact_all] = u_exact_func(nodes(:,1), nodes(:,2));
            patch('Faces', elems, 'Vertices', nodes, ...
                  'FaceVertexCData', u_exact_all, 'FaceColor', 'interp', 'EdgeColor', 'none');
            colorbar;
            title('制造解 u_x', 'FontSize', 12, 'FontWeight', 'bold');
            xlabel('x', 'FontSize', 10); ylabel('y', 'FontSize', 10);
            axis equal tight; grid on;

            subplot(2, 3, 5);
            error_mag = sqrt((Ux - u_exact_all).^2 + (Uy - v_exact_all).^2);
            patch('Faces', elems, 'Vertices', nodes, ...
                  'FaceVertexCData', log10(error_mag+1e-16), 'FaceColor', 'interp', 'EdgeColor', 'none');
            colorbar;
            title('误差幅值 (log10)', 'FontSize', 12, 'FontWeight', 'bold');
            xlabel('x', 'FontSize', 10); ylabel('y', 'FontSize', 10);
            axis equal tight; grid on;

            saveas(gcf, sprintf('verification_level_%d.png', level));
            fprintf('  图形已保存为 verification_level_%d.png\n', level);
        else
            saveas(gcf, 'engineering_solution.png');
            fprintf('  图形已保存为 engineering_solution.png\n');
        end
    end
end

if manufactured_solution && refinement_levels > 1
    fprintf('\n\n=========================================\n');
    fprintf('       收敛率分析报告\n');
    fprintf('=========================================\n\n');
    
    fprintf('网格尺寸 h: ');
    fprintf('%.4f ', h_values);
    fprintf('\n');
    
    fprintf('相对L₂误差: ');
    fprintf('%.4e ', L2_errors);
    fprintf('\n');
    
    fprintf('相对H₁误差: ');
    fprintf('%.4e ', H1_errors);
    fprintf('\n\n');
    
    fprintf('收敛率:\n');
    for level = 2:refinement_levels
        fprintf('  h: %.4f → %.4f\n', h_values(level-1), h_values(level));
        fprintf('    L₂收敛率: %.3f (理论: 2.0)\n', L2_rates(level-1));
        fprintf('    H₁收敛率: %.3f (理论: 1.0)\n', H1_rates(level-1));

        if abs(L2_rates(level-1) - 2.0) < 0.5
            fprintf('    L₂收敛率 ✓ 接近理论值\n');
        else
            fprintf('    L₂收敛率 ✗ 偏离理论值\n');
        end
        
        if abs(H1_rates(level-1) - 1.0) < 0.3
            fprintf('    H₁收敛率 ✓ 接近理论值\n');
        else
            fprintf('    H₁收敛率 ✗ 偏离理论值\n');
        end
        fprintf('\n');
    end

    figure('Position', [100, 100, 800, 600], ...
           'Name', '收敛率分析', 'NumberTitle', 'off');
    
    loglog(h_values, L2_errors, 'b-o', 'LineWidth', 2, 'MarkerSize', 8, ...
           'DisplayName', 'L₂误差');
    hold on;
    loglog(h_values, H1_errors, 'r-s', 'LineWidth', 2, 'MarkerSize', 8, ...
           'DisplayName', 'H₁误差');

    ref_h = [min(h_values), max(h_values)];
    ref_L2 = L2_errors(1) * (ref_h / h_values(1)).^2;
    ref_H1 = H1_errors(1) * (ref_h / h_values(1)).^1;
    
    loglog(ref_h, ref_L2, 'b--', 'LineWidth', 1.5, ...
           'DisplayName', 'O(h²)');
    loglog(ref_h, ref_H1, 'r--', 'LineWidth', 1.5, ...
           'DisplayName', 'O(h¹)');
    
    xlabel('网格尺寸 h', 'FontSize', 12);
    ylabel('相对误差', 'FontSize', 12);
    title('有限元收敛率分析 (Q4单元)', 'FontSize', 14, 'FontWeight', 'bold');
    legend('Location', 'best', 'FontSize', 10);
    grid on;

    for level = 2:refinement_levels
        text(h_values(level)*1.1, L2_errors(level)*0.8, ...
             sprintf('%.2f', L2_rates(level-1)), ...
             'FontSize', 9, 'Color', 'b');
        text(h_values(level)*1.1, H1_errors(level)*1.2, ...
             sprintf('%.2f', H1_rates(level-1)), ...
             'FontSize', 9, 'Color', 'r');
    end
    
    saveas(gcf, 'convergence_analysis.png');
    fprintf('收敛率分析图已保存为 convergence_analysis.png\n');

    fprintf('\n--- 误差分析总结 ---\n');
    fprintf('对于Q4线性单元:\n');
    fprintf('  理论收敛率: L₂误差 = O(h²), H₁误差 = O(h¹)\n');
    fprintf('  观察结果:\n');
    
    avg_L2_rate = mean(L2_rates);
    avg_H1_rate = mean(H1_rates);
    
    fprintf('  平均L₂收敛率: %.3f\n', avg_L2_rate);
    fprintf('  平均H₁收敛率: %.3f\n', avg_H1_rate);
    
    if avg_L2_rate > 1.5 && avg_L2_rate < 2.5
        fprintf('  ✓ L₂收敛率接近理论值\n');
    else
        fprintf('  ✗ L₂收敛率偏离理论值\n');
    end
    
    if avg_H1_rate > 0.7 && avg_H1_rate < 1.3
        fprintf('  ✓ H₁收敛率接近理论值\n');
    else
        fprintf('  ✗ H₁收敛率偏离理论值\n');
    end

    fid = fopen('convergence_report.txt', 'w');
    fprintf(fid, '=========================================\n');
    fprintf(fid, '       制造解验证 - 收敛率分析报告\n');
    fprintf(fid, '=========================================\n\n');
    
    fprintf(fid, '分析类型: %s\n', analysis_type);
    fprintf(fid, '制造解: u_x = 0.01*(x²y + sin(πx)cos(πy))\n');
    fprintf(fid, '        u_y = 0.005*(xy² + cos(πx)sin(πy))\n\n');
    
    fprintf(fid, '网格细化级别: %d\n', refinement_levels);
    fprintf(fid, '单元类型: Q4四边形单元\n\n');
    
    fprintf(fid, '%-10s %-12s %-12s %-12s %-12s\n', ...
            '级别', 'h', 'L₂误差', 'H₁误差', 'L₂率', 'H₁率');
    fprintf(fid, '%-10s %-12s %-12s %-12s %-12s\n', ...
            '----', '--', '------', '------', '----', '----');
    
    for level = 1:refinement_levels
        if level == 1
            fprintf(fid, '%-10d %-12.4f %-12.4e %-12.4e %-12s %-12s\n', ...
                    level, h_values(level), L2_errors(level), H1_errors(level), '-', '-');
        else
            fprintf(fid, '%-10d %-12.4f %-12.4e %-12.4e %-12.3f %-12.3f\n', ...
                    level, h_values(level), L2_errors(level), H1_errors(level), ...
                    L2_rates(level-1), H1_rates(level-1));
        end
    end
    
    fprintf(fid, '\n理论收敛率: L₂误差 = O(h²), H₁误差 = O(h¹)\n');
    fprintf(fid, '平均收敛率: L₂ = %.3f, H₁ = %.3f\n', avg_L2_rate, avg_H1_rate);
    
    if avg_L2_rate > 1.8 && avg_L2_rate < 2.2
        fprintf(fid, 'L₂收敛率: 良好 (接近理论值)\n');
    elseif avg_L2_rate > 1.5 && avg_L2_rate < 2.5
        fprintf(fid, 'L₂收敛率: 可接受\n');
    else
        fprintf(fid, 'L₂收敛率: 需要检查 (偏离理论值)\n');
    end
    
    if avg_H1_rate > 0.9 && avg_H1_rate < 1.1
        fprintf(fid, 'H₁收敛率: 良好 (接近理论值)\n');
    elseif avg_H1_rate > 0.7 && avg_H1_rate < 1.3
        fprintf(fid, 'H₁收敛率: 可接受\n');
    else
        fprintf(fid, 'H₁收敛率: 需要检查 (偏离理论值)\n');
    end
    
    fprintf(fid, '\n生成文件:\n');
    fprintf(fid, '  convergence_analysis.png - 收敛率图\n');
    fprintf(fid, '  convergence_report.txt  - 本报告\n');
    for level = 1:refinement_levels
        fprintf(fid, '  verification_level_%d.png - 结果图\n', level);
    end
    
    fprintf(fid, '\n分析完成时间: %s\n', datestr(now));
    fprintf(fid, '=========================================\n');
    fclose(fid);
    
    fprintf('\n报告已保存为 convergence_report.txt\n');
end

fprintf('\n\n=========================================\n');
fprintf('       分析完成！\n');
fprintf('=========================================\n');

if manufactured_solution
    fprintf('\n制造解验证完成。\n');
    fprintf('请检查 convergence_report.txt 查看详细结果。\n');
else
    fprintf('\n实际工程问题分析完成。\n');
    fprintf('结果已保存到相关文件中。\n');
end
